#!/bin/bash
# ‚ö†Ô∏è  FICHIER CRITIQUE - NE JAMAIS SUPPRIMER ‚ö†Ô∏è
# smart_categorize_dual_ai.sh - Double IA qui d√©battent pour cat√©goriser

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/config/settings.sh"
source "$SCRIPT_DIR/lib/safe_functions.sh"

# Fonction pour extraire le texte des r√©ponses JSON des IA
extract_text_from_json() {
    local json="$1"
    local api_type="$2"  # "gemini" ou "claude"
    
    # Essayer Python en premier
    local result
    if [ "$api_type" = "gemini" ]; then
        result=$(echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data['candidates'][0]['content']['parts'][0]['text'].strip())
except: pass" 2>/dev/null)
    else  # claude
        result=$(echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data['content'][0]['text'].strip())
except: pass" 2>/dev/null)
    fi
    
    # Si vide, essayer grep
    if [ -z "$result" ]; then
        result=$(echo "$json" | grep -oP '(?<="text"\s*:\s*")[^"]*' | head -1 | sed 's/\\n//g')
    fi
    
    echo "$result"
}

# Mode debug
SHOW_PROMPTS="1"  # FORC√â EN DEBUG

# Obtenir toutes les cat√©gories avec leur hi√©rarchie
get_all_categories_with_hierarchy() {
    echo "[DEBUG] R√©cup√©ration des cat√©gories AVEC hi√©rarchie..." >&2
    
    # R√©cup√©rer TOUTES les cat√©gories (pas seulement les finales)
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
    WITH RECURSIVE category_path AS (
        -- Cas de base : cat√©gories sans parent
        SELECT 
            t.term_id,
            t.name,
            tt.parent,
            CAST(t.name AS CHAR(1000)) AS path,
            t.term_id AS final_id,
            t.name AS final_name
        FROM wp_${SITE_ID}_terms t
        JOIN wp_${SITE_ID}_term_taxonomy tt ON t.term_id = tt.term_id
        WHERE tt.taxonomy = 'product_cat' 
        AND tt.parent = 0
        AND t.term_id NOT IN (15, 16)
        
        UNION ALL
        
        -- Cas r√©cursif : ajouter les enfants
        SELECT 
            t.term_id,
            t.name,
            tt.parent,
            CONCAT(cp.path, ' > ', t.name) AS path,
            t.term_id AS final_id,
            t.name AS final_name
        FROM wp_${SITE_ID}_terms t
        JOIN wp_${SITE_ID}_term_taxonomy tt ON t.term_id = tt.term_id
        JOIN category_path cp ON tt.parent = cp.term_id
        WHERE tt.taxonomy = 'product_cat'
    )
    SELECT CONCAT(path, ' (ID:', final_id, ')') AS category_line
    FROM category_path
    WHERE final_id NOT IN (
        SELECT DISTINCT parent 
        FROM wp_${SITE_ID}_term_taxonomy 
        WHERE taxonomy = 'product_cat' AND parent != 0
    )
    ORDER BY path
    " 2>/dev/null
}

# Obtenir la hi√©rarchie compl√®te d'une cat√©gorie
get_category_with_parent() {
    local cat_id=$1
    echo "[DEBUG] Recherche hi√©rarchie pour cat_id='$cat_id'" >&2
    [ -z "$cat_id" ] && { echo "[DEBUG] ERREUR : cat_id vide !" >&2; return; }
    
    # Fonction r√©cursive pour remonter toute la hi√©rarchie
    get_full_path() {
        local id=$1
        local result=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
        SELECT t.name, tt.parent
        FROM wp_${SITE_ID}_terms t
        JOIN wp_${SITE_ID}_term_taxonomy tt ON t.term_id = tt.term_id
        WHERE t.term_id = $id" 2>/dev/null)
        
        if [ -n "$result" ]; then
            local name=$(echo "$result" | cut -f1)
            local parent=$(echo "$result" | cut -f2)
            
            if [ "$parent" != "0" ] && [ -n "$parent" ]; then
                local parent_path=$(get_full_path $parent)
                echo "$parent_path > $name"
            else
                echo "$name"
            fi
        fi
    }
    
    local full_path=$(get_full_path $cat_id)
    echo "[DEBUG] Hi√©rarchie trouv√©e : '$full_path'" >&2
    echo "$full_path"
}

# Demander √† Gemini
ask_gemini() {
    echo "[DEBUG] === D√âBUT ask_gemini ===" >&2
    local title="$1"
    local authors="$2"
    local description="$3"
    local categories_list="$4"
    local previous_claude_response="${5:-}"
    
    echo "[DEBUG] Param√®tres re√ßus :" >&2
    echo "[DEBUG]   title='${title:0:50}...'" >&2
    echo "[DEBUG]   authors='$authors'" >&2
    echo "[DEBUG]   description length=$(echo "$description" | wc -c)" >&2
    echo "[DEBUG]   categories count=$(echo "$categories_list" | wc -l)" >&2
    echo "[DEBUG]   previous_claude='$previous_claude_response'" >&2
    
    # Pr√©parer le prompt
    local prompt="Tu dois cat√©goriser ce livre dans LA cat√©gorie la plus appropri√©e.

LIVRE √Ä CAT√âGORISER:
Titre: $title
Auteurs: $authors
Description: $(echo "$description" | cut -c1-500)

CAT√âGORIES DISPONIBLES (avec hi√©rarchie compl√®te):
$categories_list

INSTRUCTIONS CRITIQUES:
1. Les cat√©gories sont affich√©es avec leur hi√©rarchie compl√®te (Parent > Enfant > Petite-enfant)
2. Tu dois choisir UNE SEULE cat√©gorie FINALE (la plus sp√©cifique)
3. L'ID est indiqu√© entre parenth√®ses √† la fin : (ID:XXX)
4. R√©ponds UNIQUEMENT avec le num√©ro ID, rien d'autre
5. Par exemple, si tu choisis 'LITT√âRATURE > Romans > Romans fran√ßais (ID:279)', r√©ponds juste: 279"

    # Si Claude a d√©j√† r√©pondu
    if [ -n "$previous_claude_response" ]; then
        prompt="$prompt

Note: Claude a sugg√©r√© la cat√©gorie ID:$previous_claude_response
Es-tu d'accord ? Si oui r√©ponds le m√™me ID, sinon donne ton choix."
    fi

    # Afficher le prompt si DEBUG
    if [ "$SHOW_PROMPTS" = "1" ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üì§ PROMPT ENVOY√â √Ä GEMINI :"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "$prompt" | head -50
        echo "... [tronqu√© pour l'affichage]"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
    fi

    # √âchapper pour JSON
    echo "[DEBUG] √âchappement du prompt pour JSON..." >&2
    local prompt_escaped=$(echo "$prompt" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    echo "[DEBUG] Prompt √©chapp√© (50 car) : ${prompt_escaped:0:50}..." >&2
    
    # Cr√©er le JSON de la requ√™te
    local json_request="{
        \"contents\": [{
            \"parts\": [{
                \"text\": \"$prompt_escaped\"
            }]
        }],
        \"generationConfig\": {
            \"temperature\": 0.3,
            \"maxOutputTokens\": 20
        }
    }"
    
    # Appel √† Gemini
    echo "[DEBUG] Appel curl vers Gemini API..." >&2
    echo "[DEBUG] URL : ${GEMINI_API_URL}?key=${GEMINI_API_KEY:0:10}..." >&2
    
    local response=$(curl -s -X POST "${GEMINI_API_URL}?key=${GEMINI_API_KEY}" \
        -H "Content-Type: application/json" \
        -d "$json_request" 2>&1)
    
    local curl_status=$?
    echo "[DEBUG] Statut curl : $curl_status" >&2
    echo "[DEBUG] Taille r√©ponse : $(echo "$response" | wc -c) caract√®res" >&2
    
    # DEBUG : afficher la r√©ponse brute
    if [ "$SHOW_PROMPTS" = "1" ]; then
        echo "üì• R√âPONSE GEMINI (brute) :"
        echo "$response" | head -200
        echo ""
    fi
    
    # V√©rifier si c'est une erreur
    if echo "$response" | grep -q '"error"'; then
        echo "[DEBUG] ERREUR d√©tect√©e dans la r√©ponse Gemini !" >&2
        echo "[DEBUG] Erreur : $(echo "$response" | grep -o '"message":"[^"]*"')" >&2
        return 1
    fi
    
    # Extraire la r√©ponse - m√©thode corrig√©e
    echo "[DEBUG] Extraction de l'ID depuis la r√©ponse..." >&2
    local extracted_id=""
    
    # Chercher le pattern "text":"XXX" et extraire XXX
    local text_content=$(extract_text_from_json "$response" "gemini")
    echo "[DEBUG] Contenu text brut : '$text_content'" >&2
    
    # Nettoyer et extraire uniquement les chiffres
    extracted_id=$(echo "$text_content" | sed 's/\\n//g' | grep -o '[0-9]\+' | head -1)
    echo "[DEBUG] ID extrait apr√®s nettoyage : '$extracted_id'" >&2
    
    if [ "$SHOW_PROMPTS" = "1" ] && [ -n "$extracted_id" ]; then
        echo "üî¢ ID final extrait de Gemini : $extracted_id"
        echo ""
    fi
    
    echo "[DEBUG] === FIN ask_gemini, retour : '$extracted_id' ===" >&2
    echo "$extracted_id"
}

# Demander √† Claude
ask_claude() {
    echo "[DEBUG] === D√âBUT ask_claude ===" >&2
    local title="$1"
    local authors="$2"
    local description="$3"
    local categories_list="$4"
    local previous_gemini_response="${5:-}"
    
    echo "[DEBUG] Param√®tres re√ßus :" >&2
    echo "[DEBUG]   title='${title:0:50}...'" >&2
    echo "[DEBUG]   authors='$authors'" >&2
    echo "[DEBUG]   description length=$(echo "$description" | wc -c)" >&2
    echo "[DEBUG]   categories count=$(echo "$categories_list" | wc -l)" >&2
    echo "[DEBUG]   previous_gemini='$previous_gemini_response'" >&2
    
    # Pr√©parer le prompt
    local prompt="Tu dois cat√©goriser ce livre dans LA cat√©gorie la plus appropri√©e.

LIVRE √Ä CAT√âGORISER:
Titre: $title
Auteurs: $authors
Description: $(echo "$description" | cut -c1-500)

CAT√âGORIES DISPONIBLES (avec hi√©rarchie compl√®te):
$categories_list

INSTRUCTIONS CRITIQUES:
1. Les cat√©gories sont affich√©es avec leur hi√©rarchie compl√®te (Parent > Enfant > Petite-enfant)
2. Tu dois choisir UNE SEULE cat√©gorie FINALE (la plus sp√©cifique)
3. L'ID est indiqu√© entre parenth√®ses √† la fin : (ID:XXX)
4. R√©ponds UNIQUEMENT avec le num√©ro ID, rien d'autre
5. Par exemple, si tu choisis 'LITT√âRATURE > Romans > Romans fran√ßais (ID:279)', r√©ponds juste: 279"

    # Si Gemini a d√©j√† r√©pondu
    if [ -n "$previous_gemini_response" ]; then
        prompt="$prompt

Note: Gemini a sugg√©r√© la cat√©gorie ID:$previous_gemini_response
Es-tu d'accord ? Si oui r√©ponds le m√™me ID, sinon donne ton choix."
    fi

    # Afficher le prompt si DEBUG
    if [ "$SHOW_PROMPTS" = "1" ]; then
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üì§ PROMPT ENVOY√â √Ä CLAUDE :"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "$prompt" | head -50
        echo "... [tronqu√© pour l'affichage]"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
    fi

    # √âchapper pour JSON
    echo "[DEBUG] √âchappement du prompt pour JSON..." >&2
    local prompt_escaped=$(echo "$prompt" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
    echo "[DEBUG] Prompt √©chapp√© (50 car) : ${prompt_escaped:0:50}..." >&2
    
    # Cr√©er le JSON de la requ√™te
    local json_request="{
        \"model\": \"claude-3-haiku-20240307\",
        \"messages\": [{
            \"role\": \"user\",
            \"content\": \"$prompt_escaped\"
        }],
        \"max_tokens\": 50
    }"
    
    # Appel √† Claude
    echo "[DEBUG] Appel curl vers Claude API..." >&2
    echo "[DEBUG] URL : $CLAUDE_API_URL" >&2
    echo "[DEBUG] API Key : ${CLAUDE_API_KEY:0:10}..." >&2
    
    local response=$(curl -s -X POST "$CLAUDE_API_URL" \
        -H "x-api-key: $CLAUDE_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -H "content-type: application/json" \
        -d "$json_request" 2>&1)
    
    local curl_status=$?
    echo "[DEBUG] Statut curl : $curl_status" >&2
    echo "[DEBUG] Taille r√©ponse : $(echo "$response" | wc -c) caract√®res" >&2
    
    # DEBUG : afficher la r√©ponse brute
    if [ "$SHOW_PROMPTS" = "1" ]; then
        echo "üì• R√âPONSE CLAUDE (brute) :"
        echo "$response" | head -200
        echo ""
    fi
    
    # V√©rifier si c'est une erreur
    if echo "$response" | grep -q '"error"'; then
        echo "[DEBUG] ERREUR d√©tect√©e dans la r√©ponse Claude !" >&2
        echo "[DEBUG] Erreur : $(echo "$response" | grep -o '"message":"[^"]*"')" >&2
        return 1
    fi
    
    # Extraire la r√©ponse - m√©thode corrig√©e
    echo "[DEBUG] Extraction de l'ID depuis la r√©ponse..." >&2
    local extracted_id=""
    
    # Chercher le pattern "text":"XXX" et extraire XXX
    local claude_text=$(extract_text_from_json "$response" "claude")
    echo "[DEBUG] Texte extrait : '$claude_text'" >&2
    
    # Si Claude dit qu'il est d'accord, prendre la suggestion
    if echo "$claude_text" | grep -qi "d'accord\|agree\|oui\|yes"; then
        echo "[DEBUG] Claude semble d'accord avec Gemini" >&2
        if [ -n "$previous_gemini_response" ]; then
            extracted_id="$previous_gemini_response"
        fi
    fi
    
    # Si pas d'ID trouv√©, extraire les chiffres
    if [ -z "$extracted_id" ]; then
        extracted_id=$(echo "$claude_text" | grep -o '[0-9]\+' | head -1)
        echo "[DEBUG] ID extrait des chiffres : '$extracted_id'" >&2
    fi
    
    if [ "$SHOW_PROMPTS" = "1" ] && [ -n "$extracted_id" ]; then
        echo "üî¢ ID final extrait de Claude : $extracted_id"
        echo ""
    fi
    
    echo "[DEBUG] === FIN ask_claude, retour : '$extracted_id' ===" >&2
    echo "$extracted_id"
}

# Fonction principale de cat√©gorisation
categorize_with_dual_ai() {
    local post_id="$1"
    echo "[DEBUG] === D√âBUT categorize_with_dual_ai pour post_id=$post_id ===" >&2
    
    # R√©cup√©rer les infos du livre
    echo "[DEBUG] R√©cup√©ration des infos du livre ID $post_id..." >&2
    local book_info=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
    SELECT 
        p.post_title,
        IFNULL(pm_isbn.meta_value, '') as isbn,
        IFNULL(pm_authors.meta_value, IFNULL(pm_authors2.meta_value, '')) as authors,
        IFNULL(pm_desc.meta_value, IFNULL(pm_desc2.meta_value, '')) as description
    FROM wp_${SITE_ID}_posts p
    LEFT JOIN wp_${SITE_ID}_postmeta pm_isbn ON p.ID = pm_isbn.post_id AND pm_isbn.meta_key = '_isbn'
    LEFT JOIN wp_${SITE_ID}_postmeta pm_authors ON p.ID = pm_authors.post_id AND pm_authors.meta_key = '_best_authors'
    LEFT JOIN wp_${SITE_ID}_postmeta pm_authors2 ON p.ID = pm_authors2.post_id AND pm_authors2.meta_key = '_g_authors'
    LEFT JOIN wp_${SITE_ID}_postmeta pm_desc ON p.ID = pm_desc.post_id AND pm_desc.meta_key = '_best_description'
    LEFT JOIN wp_${SITE_ID}_postmeta pm_desc2 ON p.ID = pm_desc2.post_id AND pm_desc2.meta_key = '_g_description'
    WHERE p.ID = $post_id
    " 2>/dev/null)
    
    echo "[DEBUG] book_info trouv√© : $(echo "$book_info" | wc -c) caract√®res" >&2
    
    if [ -z "$book_info" ]; then
        echo "[DEBUG] ERREUR : Aucune info trouv√©e pour ID $post_id" >&2
        echo "‚ùå Livre ID $post_id non trouv√©"
        return 1
    fi
    
    # Parser les infos
    IFS=$'\t' read -r title isbn authors description <<< "$book_info"
    echo "[DEBUG] Infos pars√©es :" >&2
    echo "[DEBUG]   title='$title'" >&2
    echo "[DEBUG]   isbn='$isbn'" >&2
    echo "[DEBUG]   authors='$authors'" >&2
    echo "[DEBUG]   description length=$(echo "$description" | wc -c)" >&2
    
    # Nettoyer le titre s'il commence par "Livre ISBN"
    if [[ "$title" =~ ^Livre[[:space:]]+[0-9]+ ]]; then
        echo "[DEBUG] Titre g√©n√©rique d√©tect√©, recherche du vrai titre..." >&2
        # Chercher _best_title ou _g_title
        local real_title=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
        SELECT IFNULL(
            (SELECT meta_value FROM wp_${SITE_ID}_postmeta WHERE post_id = $post_id AND meta_key = '_best_title' LIMIT 1),
            (SELECT meta_value FROM wp_${SITE_ID}_postmeta WHERE post_id = $post_id AND meta_key = '_g_title' LIMIT 1)
        )" 2>/dev/null)
        
        if [ -n "$real_title" ] && [ "$real_title" != "NULL" ]; then
            title="$real_title"
            echo "[DEBUG] Vrai titre trouv√© : '$title'" >&2
        fi
    fi
    
    echo ""
    echo "üìö LIVRE : $title"
    echo "   ISBN : ${isbn:-N/A}"
    echo "   Auteurs : ${authors:-N/A}"
    
    # Afficher la description
    if [ -n "$description" ] && [ "$description" != "NULL" ]; then
        echo "   Description : $(echo "$description" | sed 's/<[^>]*>//g' | cut -c1-150)..."
    else
        echo "   Description : Non disponible"
    fi
    echo ""
    
    # Obtenir la liste des cat√©gories AVEC HI√âRARCHIE
    echo "üìã R√©cup√©ration des cat√©gories avec hi√©rarchie..."
    local categories_list=$(get_all_categories_with_hierarchy)
    local cat_count=$(echo "$categories_list" | wc -l)
    echo "   $cat_count cat√©gories disponibles"
    echo "[DEBUG] Exemples de cat√©gories avec hi√©rarchie :" >&2
    echo "$categories_list" | head -5 | while read line; do
        echo "[DEBUG]   $line" >&2
    done
    
    # Premier round : demander aux deux IA
    echo ""
    echo "ü§ñ ROUND 1 - Premi√®re analyse..."
    
    echo -n "   Gemini analyse... "
    echo "[DEBUG] Appel ask_gemini Round 1..." >&2
    local gemini_choice_1=$(ask_gemini "$title" "$authors" "$description" "$categories_list")
    echo "[DEBUG] Retour ask_gemini Round 1 : '$gemini_choice_1'" >&2
    
    if [ -n "$gemini_choice_1" ] && [[ "$gemini_choice_1" =~ ^[0-9]+$ ]]; then
        local gemini_cat_1=$(get_category_with_parent "$gemini_choice_1")
        echo "Gemini choisit : $gemini_cat_1"
    else
        echo "[DEBUG] ERREUR : gemini_choice_1 invalide : '$gemini_choice_1'" >&2
        echo "Gemini ne r√©pond pas correctement !"
        return 1
    fi
    
    echo -n "   Claude analyse... "
    echo "[DEBUG] Appel ask_claude Round 1..." >&2
    local claude_choice_1=$(ask_claude "$title" "$authors" "$description" "$categories_list")
    echo "[DEBUG] Retour ask_claude Round 1 : '$claude_choice_1'" >&2
    
    if [ -n "$claude_choice_1" ] && [[ "$claude_choice_1" =~ ^[0-9]+$ ]]; then
        local claude_cat_1=$(get_category_with_parent "$claude_choice_1")
        echo "Claude choisit : $claude_cat_1"
    else
        echo "[DEBUG] ERREUR : claude_choice_1 invalide : '$claude_choice_1'" >&2
        echo "Claude ne r√©pond pas correctement !"
        return 1
    fi
    
    # V√©rifier si accord
    echo "[DEBUG] Comparaison : gemini='$gemini_choice_1' vs claude='$claude_choice_1'" >&2
    if [ "$gemini_choice_1" = "$claude_choice_1" ]; then
        echo ""
        echo "‚úÖ ACCORD IMM√âDIAT sur : $gemini_cat_1"
        local final_choice=$gemini_choice_1
    else
        # D√©saccord - Round 2
        echo ""
        echo "‚ùå D√âSACCORD ! Round 2..."
        
        echo -n "   Gemini reconsid√®re... "
        echo "[DEBUG] Appel ask_gemini Round 2 avec suggestion Claude=$claude_choice_1..." >&2
        local gemini_choice_2=$(ask_gemini "$title" "$authors" "$description" "$categories_list" "$claude_choice_1")
        echo "[DEBUG] Retour ask_gemini Round 2 : '$gemini_choice_2'" >&2
        
        if [ -n "$gemini_choice_2" ] && [[ "$gemini_choice_2" =~ ^[0-9]+$ ]]; then
            local gemini_cat_2=$(get_category_with_parent "$gemini_choice_2")
            echo "Gemini change pour : $gemini_cat_2"
        else
            echo "Gemini garde son choix"
            gemini_choice_2=$gemini_choice_1
            gemini_cat_2=$gemini_cat_1
        fi
        
        echo -n "   Claude reconsid√®re... "
        echo "[DEBUG] Appel ask_claude Round 2 avec suggestion Gemini=$gemini_choice_1..." >&2
        local claude_choice_2=$(ask_claude "$title" "$authors" "$description" "$categories_list" "$gemini_choice_1")
        echo "[DEBUG] Retour ask_claude Round 2 : '$claude_choice_2'" >&2
        
        if [ -n "$claude_choice_2" ] && [[ "$claude_choice_2" =~ ^[0-9]+$ ]]; then
            local claude_cat_2=$(get_category_with_parent "$claude_choice_2")
            echo "Claude change pour : $claude_cat_2"
        else
            echo "Claude garde son choix"
            claude_choice_2=$claude_choice_1
            claude_cat_2=$claude_cat_1
        fi
        
        # R√©sultat final
        echo "[DEBUG] Comparaison Round 2 : gemini='$gemini_choice_2' vs claude='$claude_choice_2'" >&2
        if [ "$gemini_choice_2" = "$claude_choice_2" ]; then
            echo ""
            echo "‚úÖ CONSENSUS TROUV√â sur : $gemini_cat_2"
            local final_choice=$gemini_choice_2
        else
            echo ""
            echo "‚ö†Ô∏è  PAS DE CONSENSUS"
            echo "   Choix final de Gemini : $gemini_cat_2"
            echo "   Choix final de Claude : $claude_cat_2"
            # En cas de d√©saccord persistant, prendre Claude
            local final_choice=$claude_choice_2
            echo "   ‚Üí Choix retenu : $claude_cat_2 (Claude)"
        fi
    fi
    
    echo "[DEBUG] Choix final : ID=$final_choice" >&2
    
    # V√©rifier que final_choice est valide
    if [ -z "$final_choice" ] || ! [[ "$final_choice" =~ ^[0-9]+$ ]]; then
        echo "[DEBUG] ERREUR : final_choice invalide : '$final_choice'" >&2
        echo "‚ùå Erreur : Aucune cat√©gorie valide choisie"
        return 1
    fi
    
    # R√©cup√©rer le nom complet de la cat√©gorie finale
    local final_cat_name=$(get_category_with_parent "$final_choice")
    
    echo ""
    echo "üìå CAT√âGORIE FINALE : $final_cat_name"
    
    # Appliquer la cat√©gorie
    echo -n "üíæ Application... "
    
    # Obtenir le term_taxonomy_id
    echo "[DEBUG] Recherche term_taxonomy_id pour term_id=$final_choice..." >&2
    local term_taxonomy_id=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
    SELECT term_taxonomy_id FROM wp_${SITE_ID}_term_taxonomy 
    WHERE term_id = $final_choice AND taxonomy = 'product_cat'
    " 2>/dev/null)
    
    echo "[DEBUG] term_taxonomy_id trouv√© : '$term_taxonomy_id'" >&2
    
    if [ -z "$term_taxonomy_id" ]; then
        echo "[DEBUG] ERREUR : term_taxonomy_id non trouv√© pour term_id=$final_choice" >&2
        echo "‚ùå Cat√©gorie introuvable !"
        return 1
    fi
    
    # Supprimer anciennes cat√©gories
    echo "[DEBUG] Suppression des anciennes cat√©gories..." >&2
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -e "
    DELETE FROM wp_${SITE_ID}_term_relationships 
    WHERE object_id = $post_id 
    AND term_taxonomy_id IN (
        SELECT term_taxonomy_id FROM wp_${SITE_ID}_term_taxonomy 
        WHERE taxonomy = 'product_cat'
    )
    " 2>/dev/null
    
    # Ajouter nouvelle cat√©gorie
    echo "[DEBUG] Ajout de la nouvelle cat√©gorie term_taxonomy_id=$term_taxonomy_id..." >&2
    mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -e "
    INSERT IGNORE INTO wp_${SITE_ID}_term_relationships (object_id, term_taxonomy_id)
    VALUES ($post_id, $term_taxonomy_id)
    " 2>/dev/null
    
    echo "‚úÖ Fait!"
    
    # Log
    mkdir -p "$LOG_DIR"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ID:$post_id - $title ‚Üí $final_cat_name" >> "$LOG_DIR/dual_ai_categorize.log"
    
    echo "[DEBUG] === FIN categorize_with_dual_ai ===" >&2
}

# Programme principal
clear
echo "=== SMART CATEGORIZE - DUAL AI MODE ==="
echo "Gemini + Claude d√©battent pour trouver la meilleure cat√©gorie"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# V√©rifier les cl√©s
echo "[DEBUG] V√©rification des cl√©s API..." >&2
echo "[DEBUG] GEMINI_API_KEY : ${GEMINI_API_KEY:0:10}..." >&2
echo "[DEBUG] CLAUDE_API_KEY : ${CLAUDE_API_KEY:0:10}..." >&2

if [ -z "$GEMINI_API_KEY" ] || [ -z "$CLAUDE_API_KEY" ]; then
    echo "‚ùå ERREUR : Les deux cl√©s API sont requises"
    echo "Lancez : ./setup_dual_ai.sh"
    exit 1
fi

# Si mode debug
if [ "$SHOW_PROMPTS" = "1" ]; then
    echo ""
    echo "üîç MODE DEBUG ACTIV√â - Les prompts seront affich√©s"
    echo ""
fi

# Menu
if [ -z "$1" ]; then
    echo ""
    echo "Usage :"
    echo "  ./smart_categorize_dual_ai.sh ISBN"
    echo "  ./smart_categorize_dual_ai.sh -id ID"
    echo "  ./smart_categorize_dual_ai.sh -batch N"
    echo ""
    echo "Mode debug : SHOW_PROMPTS=1 ./smart_categorize_dual_ai.sh ISBN"
    echo ""
    echo -n "ISBN ou ID du livre : "
    read input
else
    input="$1"
fi

echo "[DEBUG] Input re√ßu : '$input'" >&2

# Traiter l'input
case "$input" in
    -id)
        echo "[DEBUG] Mode ID direct : ID=$2" >&2
        categorize_with_dual_ai "$2"
        ;;
    -batch)
        limit="${2:-5}"
        echo "Cat√©gorisation de $limit livres..."
        echo "[DEBUG] Recherche de $limit livres sans cat√©gorie..." >&2
        mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
        SELECT DISTINCT p.ID
        FROM wp_${SITE_ID}_posts p
        LEFT JOIN wp_${SITE_ID}_term_relationships tr ON p.ID = tr.object_id
        LEFT JOIN wp_${SITE_ID}_term_taxonomy tt ON tr.term_taxonomy_id = tt.term_taxonomy_id
        WHERE p.post_type = 'product'
        AND p.post_status = 'publish'
        AND (tt.taxonomy != 'product_cat' OR tt.taxonomy IS NULL)
        LIMIT $limit
        " 2>/dev/null | while read post_id; do
            echo "[DEBUG] Traitement du livre ID=$post_id" >&2
            categorize_with_dual_ai "$post_id"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            sleep 2  # Pause entre chaque livre
        done
        ;;
    *)
        # Chercher par ISBN
        echo "[DEBUG] Recherche par ISBN : '$input'" >&2
        post_id=$(mysql -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sN -e "
        SELECT post_id FROM wp_${SITE_ID}_postmeta 
        WHERE meta_key = '_isbn' AND meta_value = '$input'
        LIMIT 1
        " 2>/dev/null)
        
        echo "[DEBUG] Post ID trouv√© : '$post_id'" >&2
        
        if [ -n "$post_id" ]; then
            categorize_with_dual_ai "$post_id"
        else
            echo "‚ùå ISBN '$input' non trouv√©"
        fi
        ;;
esac

echo ""
echo "üìä Logs : $LOG_DIR/dual_ai_categorize.log"